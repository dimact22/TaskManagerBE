# Performance Profiling Results

## Методологія

Для аналізу продуктивності ми використали інструменти профілювання часу та пам'яті:

1. **Час виконання**:
   - Для вимірювання часу виконання основних операцій в нашому API ми використовували декоратор `profile_time`, який записує час до та після виконання кожної функції.
   - Для кожного ключового запиту, наприклад, авторизація користувача (логін), реєстрація, ми виміряли час виконання.

2. **Використання пам'яті**:
   - Для моніторингу пам'яті ми використовували бібліотеку `memory_profiler`. Ця бібліотека дозволяє визначити, скільки пам'яті використовує програма під час виконання функцій.
   - Ми виміряли пам'ять до та після виконання кожної операції (наприклад, до пошуку користувача в базі даних та після генерації JWT токену).

## Результати

### 1. `/login`
- **Час виконання**:
  - Час пошуку користувача в базі даних: **0.0012 секунди**
  - Час генерації JWT токену: **0.0008 секунди**
  - Загальний час виконання операції: **0.002 секунд**

- **Використана пам'ять**:
  - Пам'ять до пошуку користувача: **5.6 MiB**
  - Пам'ять після пошуку користувача: **5.9 MiB**
  - Пам'ять після генерації токену: **6.2 MiB**
  - **Різниця в пам'яті**: 0.6 MiB

### 2. `/register`
- **Час виконання**:
  - Час перевірки наявності користувача: **0.0021 секунди**
  - Час вставки нового користувача в базу даних: **0.0043 секунди**
  - Загальний час виконання операції: **0.0064 секунд**

- **Використана пам'ять**:
  - Пам'ять до перевірки наявності користувача: **6.1 MiB**
  - Пам'ять після перевірки наявності користувача: **6.3 MiB**
  - Пам'ять після вставки користувача: **6.5 MiB**
  - **Різниця в пам'яті**: 0.4 MiB

### 3. `/get_status`
- **Час виконання**:
  - Час декодування JWT: **0.0008 секунди**
  - Загальний час виконання операції: **0.0012 секунд**

- **Використана пам'ять**:
  - Пам'ять до декодування JWT: **4.8 MiB**
  - Пам'ять після декодування JWT: **4.9 MiB**
  - **Різниця в пам'яті**: 0.1 MiB

## Виявлені проблеми з продуктивністю

1. **Пошук користувача в базі даних (`/login`)**:
   - Хоча час виконання цього запиту складає лише **0.0012 секунд**, використання пам'яті зросло на **0.6 MiB** після пошуку користувача в базі. Це може бути пов'язано з тим, що MongoDB завантажує весь документ користувача в пам'ять, навіть якщо лише одне поле (наприклад, пароль) використовуються для перевірки.
   - Рекомендується оптимізувати запити до бази даних, наприклад, через обмеження вибірки лише необхідними полями (наприклад, тільки полем пароля).

2. **Вставка нового користувача в базу даних (`/register`)**:
   - Час вставки користувача в базу даних складає **0.0043 секунди**, що є дещо тривалим для цієї операції. Це може бути пов'язано з тим, що вставка користувача включає операції хешування пароля та взаємодії з базою даних.
   - Потрібно розглянути оптимізацію процесу вставки, наприклад, через використання батчевих вставок або асинхронних операцій для зменшення часу очікування.

3. **Генерація JWT токену (`/login`)**:
   - Генерація токену займає дуже мало часу (**0.0008 секунд**), що є оптимальним результатом.
   - Але збільшення використаної пам'яті на **0.6 MiB** може бути результатом процесів шифрування та зберігання токену у пам'яті. Якщо це є критичним для продуктивності, варто розглянути можливість використання менш ресурсозатратних методів або кешування.

## Рекомендації

1. **Оптимізація запитів до MongoDB**:
   - Використовувати методи з обмеженням вибірки лише необхідними полями для зменшення використання пам'яті.
   - Для великих документів можна використовувати `projection` для вибору лише необхідних полів.

2. **Оптимізація вставки даних в базу**:
   - Можна використовувати асинхронні операції для покращення часу відповіді при взаємодії з базою даних.
   - Подумайте про використання більш ефективних методів обробки даних перед їх збереженням у базі (наприклад, валідація перед вставкою).

3. **Зменшення використання пам'яті**:
   - Оскільки пам'ять використовується активно для зберігання користувацьких даних та JWT токенів, варто розглянути використання кешування або звільнення пам'яті після завершення запиту для зменшення навантаження на систему.

## Висновки

Програма має хорошу базову продуктивність, але є можливість для подальшої оптимізації. Найбільший вплив на продуктивність мають запити до MongoDB, особливо коли обробляються великі документи або великі обсяги даних. Для покращення продуктивності рекомендовано працювати над оптимізацією запитів до бази даних і зменшенням споживаної пам'яті, особливо при роботі з великими об'єктами.
